# DigitalOcean App Platform — Production CD Workflow
# =============================================================================
#
# HOW IT WORKS
# =============================================================================
#
# This workflow deploys Tachyon services to the DigitalOcean App Platform
# production environment. It requires manual approval via GitHub Actions
# environment protection rules and enforces that the exact same image SHAs
# validated in staging are deployed to production.
#
# Flow:
#   1. Developer triggers the workflow with the release version string (must
#      match the version field in releases/manifest.json).
#   2. The validate job reads the manifest to extract pinned image SHAs and
#      verifies that staging has been deployed for this version. If either
#      check fails, the workflow aborts before the approval gate.
#   3. GitHub pauses at the deploy job and waits for a required reviewer to
#      approve (configured via the "production" environment protection rule).
#   4. Once approved, the resolved image tags from the manifest are written
#      into the DO App Spec (.do/app.prod.yml) using Python/PyYAML — the same
#      approach as the staging workflow.
#   5. doctl pushes the updated App Spec to DigitalOcean. The --wait flag
#      blocks until the platform finishes deploying (or fails).
#   6. A health check loop polls the API's /health endpoint up to 10 times
#      (15s intervals, ~2.5 min total).
#   7. On success, the release manifest is updated with production deployment
#      metadata, then committed and pushed back to the repo.
#
# Required GitHub Secrets:
#   - DIGITALOCEAN_PROD_ACCESS_TOKEN  — DO API token for production
#   - DO_PROD_APP_ID                  — Production App Platform app ID
#
# Required GitHub Environment:
#   - production (with required reviewers configured)
#
# =============================================================================
name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirm_version:
        description: "Release version to deploy (must match releases/manifest.json)"
        required: true
        type: string

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      api_tag: ${{ steps.manifest.outputs.api_tag }}
      workers_tag: ${{ steps.manifest.outputs.workers_tag }}
      db_tag: ${{ steps.manifest.outputs.db_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Read release manifest
        id: manifest
        run: |
          VERSION=$(jq -r '.version' releases/manifest.json)
          if [ "$VERSION" != "${{ inputs.confirm_version }}" ]; then
            echo "::error::Version mismatch: manifest has ${VERSION}, input was ${{ inputs.confirm_version }}"
            exit 1
          fi
          echo "api_tag=$(jq -r '.services["tachyon-api"].tag' releases/manifest.json)" >> $GITHUB_OUTPUT
          echo "workers_tag=$(jq -r '.services["tachyon-workers"].tag' releases/manifest.json)" >> $GITHUB_OUTPUT
          echo "db_tag=$(jq -r '.services["tachyon-db-migrate"].tag' releases/manifest.json)" >> $GITHUB_OUTPUT

      - name: Verify staging deployment exists
        run: |
          STAGING_DEPLOYED=$(jq -r '.environments.staging.deployed_at' releases/manifest.json)
          if [ "$STAGING_DEPLOYED" = "" ] || [ "$STAGING_DEPLOYED" = "null" ]; then
            echo "::error::This version has not been deployed to staging yet"
            exit 1
          fi
          echo "Staging deployed at: ${STAGING_DEPLOYED}"

  deploy:
    needs: validate
    runs-on: ubuntu-latest
    environment: production  # Requires manual approval via GitHub environment protection
    steps:
      - uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_PROD_ACCESS_TOKEN }}

      # Rewrite the App Spec's image tags using the manifest-pinned SHAs from
      # the validate job. These are the exact same versions deployed to staging,
      # enforcing promotion integrity. Uses Python/PyYAML (pre-installed on
      # ubuntu-latest) to target each component individually.
      - name: Update App Spec with image tags
        run: |
          python3 -c "
          import yaml, sys

          with open('.do/app.prod.yml') as f:
              spec = yaml.safe_load(f)

          tags = {
              'tachyon-api': '${{ needs.validate.outputs.api_tag }}',
              'tachyon-workers': '${{ needs.validate.outputs.workers_tag }}',
              'tachyon-db-migrate': '${{ needs.validate.outputs.db_tag }}',
          }

          for svc in spec.get('services', []):
              if svc['name'] in tags:
                  svc['image']['tag'] = tags[svc['name']]
          for wkr in spec.get('workers', []):
              if wkr['name'] in tags:
                  wkr['image']['tag'] = tags[wkr['name']]
          for job in spec.get('jobs', []):
              if job['name'] in tags:
                  job['image']['tag'] = tags[job['name']]

          with open('.do/app.prod.yml', 'w') as f:
              yaml.dump(spec, f, default_flow_style=False, sort_keys=False)
          print('App Spec updated with production image tags')
          "

      - name: Deploy to production
        run: |
          doctl apps update ${{ secrets.DO_PROD_APP_ID }} --spec .do/app.prod.yml --wait

      - name: Verify production health
        run: |
          APP_URL=$(doctl apps get ${{ secrets.DO_PROD_APP_ID }} --output json | jq -r '.default_ingress')
          echo "Checking health at: https://${APP_URL}/health"
          for i in {1..10}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://${APP_URL}/health" || echo "000")
            if [ "$STATUS" = "200" ]; then
              echo "Production health check passed!"
              exit 0
            fi
            echo "Attempt $i: HTTP $STATUS (waiting 15s...)"
            sleep 15
          done
          echo "::error::Production health check failed"
          exit 1

      - name: Update release manifest
        run: |
          jq --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             --arg by "${{ github.actor }}" \
             '.environments.production.deployed_at = $ts |
              .environments.production.deployed_by = $by |
              .environments.production.approved_by = $by' \
             releases/manifest.json > releases/manifest.tmp.json
          mv releases/manifest.tmp.json releases/manifest.json

      - name: Commit manifest update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add releases/manifest.json
          git commit -m "chore: update production release manifest [v${{ inputs.confirm_version }}]"
          git push