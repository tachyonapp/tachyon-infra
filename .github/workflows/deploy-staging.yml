# DigitalOcean App Platform — Staging CD Workflow
# =============================================================================
#
# HOW IT WORKS
# =============================================================================
#
# This workflow deploys Tachyon services to the DigitalOcean App Platform
# staging environment. It is triggered manually (workflow_dispatch) from the
# GitHub Actions UI — it is NOT auto-triggered by GHCR image pushes.
#
# Flow:
#   1. Developer triggers the workflow, optionally providing specific commit
#      SHAs for each service image. Any omitted SHA defaults to "latest".
#   2. The resolved image tags are written into the DO App Spec (.do/app.staging.yml)
#      using Python/PyYAML to target each component (services, workers, jobs)
#      individually — (avoiding a naive global find-and-replace.)
#   3. doctl pushes the updated App Spec to DigitalOcean, which pulls the
#      specified images from GHCR and deploys them. The --wait flag blocks
#      until DO reports the deployment is complete.
#   4. A health check loop polls the API's /health endpoint up to 10 times
#      (15s intervals, ~2.5 min total). If it never returns HTTP 200, the
#      entire workflow fails.
#   5. On success, the release manifest (releases/manifest.json) is updated
#      with the deployed SHAs, timestamp, and actor — then committed and
#      pushed back to the repo. This manifest is what the production deploy
#      workflow reads to ensure prod receives the same versions validated
#      in staging.
#
# Required GitHub Secrets:
#   - DIGITALOCEAN_ACCESS_TOKEN  — DO API token for staging
#   - DO_APP_ID                  — Staging App Platform app ID
#
# Required GitHub Environment:
#   - staging
#
# =============================================================================
name: Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      api_sha:
        description: "tachyon-api image SHA (leave empty for latest)"
        required: false
        type: string
      workers_sha:
        description: "tachyon-workers image SHA (leave empty for latest)"
        required: false
        type: string
      db_sha:
        description: "tachyon-db-migrate image SHA (leave empty for latest)"
        required: false
        type: string

env:
  DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      # Resolve each service's image tag. If the operator didn't provide a
      # specific SHA, fall back to "latest" (the most recent main build).
      - name: Resolve image tags
        id: tags
        run: |
          API_TAG="${{ inputs.api_sha || 'latest' }}"
          WORKERS_TAG="${{ inputs.workers_sha || 'latest' }}"
          DB_TAG="${{ inputs.db_sha || 'latest' }}"
          echo "api_tag=${API_TAG}" >> $GITHUB_OUTPUT
          echo "workers_tag=${WORKERS_TAG}" >> $GITHUB_OUTPUT
          echo "db_tag=${DB_TAG}" >> $GITHUB_OUTPUT

      # Rewrite the App Spec's image tags per-component. Uses Python/PyYAML
      # (pre-installed on ubuntu-latest) to walk services, workers, and jobs
      # individually rather than a blind sed that would set all three to the
      # same value.
      - name: Update App Spec with image tags
        run: |
          python3 -c "
          import yaml, sys

          with open('.do/app.staging.yml') as f:
              spec = yaml.safe_load(f)

          tags = {
              'tachyon-api': '${{ steps.tags.outputs.api_tag }}',
              'tachyon-workers': '${{ steps.tags.outputs.workers_tag }}',
              'tachyon-db-migrate': '${{ steps.tags.outputs.db_tag }}',
          }

          for svc in spec.get('services', []):
              if svc['name'] in tags:
                  svc['image']['tag'] = tags[svc['name']]
          for wkr in spec.get('workers', []):
              if wkr['name'] in tags:
                  wkr['image']['tag'] = tags[wkr['name']]
          for job in spec.get('jobs', []):
              if job['name'] in tags:
                  job['image']['tag'] = tags[job['name']]

          with open('.do/app.staging.yml', 'w') as f:
              yaml.dump(spec, f, default_flow_style=False, sort_keys=False)
          print('App Spec updated with image tags')
          "

      # Push the updated App Spec to DigitalOcean. --wait blocks until the
      # platform finishes deploying (or fails).
      - name: Deploy to App Platform
        run: |
          doctl apps update ${{ secrets.DO_APP_ID }} --spec .do/app.staging.yml --wait

      # Poll the API health endpoint. Retries up to 10 times at 15s intervals
      # (~2.5 min). Exits non-zero if the service never becomes healthy.
      - name: Verify deployment health
        run: |
          APP_URL=$(doctl apps get ${{ secrets.DO_APP_ID }} --output json | jq -r '.default_ingress')
          echo "Checking health at: https://${APP_URL}/health"
          for i in {1..10}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://${APP_URL}/health" || echo "000")
            if [ "$STATUS" = "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: HTTP $STATUS (waiting 15s...)"
            sleep 15
          done
          echo "Health check failed after 10 attempts"
          exit 1

      # Write the deployed SHAs and metadata into the release manifest.
      # Both .sha and .tag are updated to keep them in sync. The production
      # deploy workflow reads this manifest to guarantee it deploys the exact
      # same versions that were validated in staging.
      - name: Update release manifest
        run: |
          jq --arg api "${{ steps.tags.outputs.api_tag }}" \
             --arg workers "${{ steps.tags.outputs.workers_tag }}" \
             --arg db "${{ steps.tags.outputs.db_tag }}" \
             --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             --arg by "${{ github.actor }}" \
             '.services["tachyon-api"].sha = $api |
              .services["tachyon-api"].tag = $api |
              .services["tachyon-workers"].sha = $workers |
              .services["tachyon-workers"].tag = $workers |
              .services["tachyon-db-migrate"].sha = $db |
              .services["tachyon-db-migrate"].tag = $db |
              .environments.staging.deployed_at = $ts |
              .environments.staging.deployed_by = $by' \
             releases/manifest.json > releases/manifest.tmp.json
          mv releases/manifest.tmp.json releases/manifest.json

      # Commit the updated manifest back to the repo so the production
      # deploy workflow can read the staging-validated versions.
      - name: Commit manifest update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add releases/manifest.json
          git commit -m "chore: update staging release manifest" || echo "No changes"
          git push
